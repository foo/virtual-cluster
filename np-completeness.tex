We have seen that even problems with multiple dimensions of
flexibility, e.g., in terms of flexible node placement 
and replica selection, and even with capacity constraints (our problem
($\FP+\RS+\BW$) can be solved in polynomial time.
This section now points out fundamental
limitations in terms of computational tractability. In particular,
we will show that problems become NP-hard if
inter-connects have to be established ($\FP+\RS+\CC$ is proved
NP-hard in Section~\ref{ssec:fprscc}) or if multiple replicas
have to be assigned to a node ($\FP+\RS+\MA$ is proved
NP-hard in Section~\ref{ssec:fprsma}); both results hold
even in uncapacitated networks, and even in fat-trees consisting
of two levels only (e.g., in a datacenter \emph{pod}). Finally, we show that
some problems are NP-hard even if the number of replicas is only two
(Section~\ref{ssec:two}).


\subsection{Inter-connects are hard}\label{ssec:fprscc}

Set cover problem is well-known NP-complete problem. Other names that
we can find this problem in literature is Hitting set problem. Many variants of
this problem remain NP-complete. One of those variants is Set cover
with restriction that every set has cardinality exactly three. We will
use this $3SC$ problem as the problem we will reduce from.

Comment:There they say that 3HS in NP-complete:
\url{http://lcbb4.epfl.ch/reading/hitting\%20set/2003-niedermeierFPT3HS.pdf}
\url{http://www.sciencedirect.com/science/article/pii/S1570866703000091}

We will exploit the fact that we can construct $\VCNB$ instance where
we set number of VMs to spawn to be greater than number of chunk
types. Those excessive VMs are not processing any chunks but they are
still communicating with eachother as well as with processing
VMs.

First, we need to take decision variant of $3SC$. It is stated the
following way. We are given the universe $U$, family of universe
subsets $S = \{ S_1, S_2, \ldots, S_n \}$ with cardinality of each set
being three, and integer $k$. The problem is to decide whether there
exist a subfamily of sets $S' \subset S$ of cardinality $k$ that
covers every element in universe.

\textbf{Construction.}
Idea of the construction is to create a chunk type for every element
of universe, and encode each subset $S_i$ as a gadget that contains
replicas of chunks that correspond to its elements. Here it is crucial
to use replication, as sets share elements of universe. Set $S_i$ is
chosen in $3SC$ instance when it has $3$ VMs spawned in it. Processing
each chunk will correspond to covering all the elements.


Let's take an instance $I$ of $3SC$. We will create VC instance $\VCNB_I$ in following
way. Let's start by setting integer constants in our instance:
\begin{itemize}
\item set transportation cost to some huge constant $\CostTrans = W$
  with idea of forbidding transportation. We will show how to
  calculate $W$ in an appendix, right now we can think about it as $W
  = \infty$.
\item set communication cost to $\CostCom = 1$
\item set number of VMS to $\Vms = 3 \cdot k$
\item set $\Thr =  3 \cdot k + 3 \cdot 3 \cdot 2 \cdot (k - 1)$
\end{itemize}


Then we construct the tree $\Tree_I$. It will have height 2 counted in number of
edges. It will consist of gadgets for every set $S_i$. Every gadget
consists of inner node and three leaves. We place three chunks in
every gadget; those chunks correspond to elements of $S_i$.

\textbf{Proof of correctness.}
Crucial property of communication cost is that VMs should stick
closely to eachother to incline minimal cost. Therefore, before
prooving correctness of our reduction we need following lemma:

\begin{lemma}
In every $\VCNB$ solution $\Sol$ of cost $\leq \Thr$ we have exactly
$3$ VMs in $k$ gadgets and rest of the $n-k$ gadgets remain empty.
\end{lemma}
\begin{proof}
First, we notice that it is never beneficial to
transport chunks, as $W$ is already exceeding $\Thr$. Also we know that
$\Sol$ is feasible, therefore $|U|$ VMs sit on top of the chunks they
are processing.

Let's look at every pair of VMs that communicate. We
will count how many VMs communicate over 2 hop and how many
communicate over 4 hops. We do it by starting with 4 hops
communication and subtracting 2 hops for every pair of VMs that sit in
the same gadget. We notice that with constant number of VMs to spawn,
the more gadgets containing VMs the less 2 hop communications there
are. Communication cost is optimal when every gadget contains exactly
3 VMs, because then we subtract 3 pair. We chosen $\Thr$ to be exactly
the cost of such solution. Therefore, no solution that spawns VMs in
more than $k$ gadgets will ever have cost $\leq \Thr$.
\end{proof}

\begin{theorem}
$I \in 3SC$ iff $\VCNB_I$ has solution of cost $\leq \Thr$.
\end{theorem}
\begin{proof}

($=>$) Let's take the covering set $S = \{S_1, S_2, \ldots, S_k\}$ and place $3$ VMs in each gadget that
corresponds to every set of $S$. We match VMs to chunks the following
way: we traverse VMs one by one, and if the VM sit on top of the chunk
type that was not yet processed, we match that them; otherwise we set
the VM to be idle. Let's calculate the cost of the solution:
\begin{itemize}
\item communication cost inside gadget is $2 \cdot {3 \choose 2}$,
  because we take every pair and add 2 hop communication cost
\item communication cost from single gadget to all other gadgets is $4
  \cdot 3 \cdot 3 \cdot (k - 1) / 2$, where $2$ is a factor inclined by
  communication over $4$ hops, $3$ is the number of VMs in the gadget,
  $3 \cdot (k-1)$ is the number of VMs that sit in other gadgets, and
  $/2$ is inclined by counting every pair twice
\end{itemize}

By summing above costs over every of $k$ gadgets, we have cost equal
to $\Thr$.

($<=$) Let's take VC solution. First, we apply our lemma that in $\leq
\Thr$-cost
solution $k$ gadgets are full of VMs. We construct our hitting set from
sets that correspond to those full gadgets. Also, we know that every
chunk type was processed. Therefore every element of universe was hit.
\end{proof}

\subsection{Multi-Assignments are hard}\label{ssec:fprsma}

3D exact matching introduction here.

\textbf{Construction.}

\begin{itemize}
\item tree consists of gadgets for each triple
\item chunks correspond to elements of X,Y and Z
\item $|X| = |Y| = |Z| = k$
\item we set TC to 1
\item we set m to 3
\item we set number of VMs to $k$
\item we set threshold to $2 \cdot 2 \cdot k$
\item each gadget consists of 3 leaves and parent; in leaves there are
  chunks that correspond to elements of a triple
\end{itemize}

\textbf{Proof}

($=>$) Let's take solution to 3D exact matching. We spawn VM in every
gadget that corresponds to chosen triples. We match every chunk in a
gadget to machine in this gadget (only for chosen ones). Solution has
cost exactly $\Thr$.

($<=$) Let's take solution to $VC$ instance of cost $\leq \Thr$. We
chose triples that correspond to gadgets where were VMs. Everything
was processed, therefore every element of X,Y and Z is matched.


\subsection{Two replicas are hard}\label{ssec:two}

It seems that replication is the property of models which makes them
hard. Therefore we decided to investigate how much we can constrain
replication and still have NP-hard problems. As last section of this
chapter we will investigate restricting replication to have at most 2
replicas of each chunk type. It turns out that this variant remains
NP-complete, when it is paired with bandwidth. Our technique is to use
$3SAT$ as a problem which we reduce from.


The idea is to reduce from 3SAT using only replication of degree
$2$. How can we simulate this behavior using only two replicas? First,
let's reduce from $3SAT$ instead of $SAT$. Our tree $T_{\Psi}$
will consist of two types of gadgets: gadgets for variables and
gadgets for clauses. Most fundamental conceptual difference is that
for every clause we create three chunk types instead of just one (like
in previous proof).

\textbf{Construction.}

We put chunks in following way. First, we put clause chunks in
variable gadgets like we did in proof of NP-completeness of 3 replica
model with the difference that now we place distinct chunks instead of
three copies of the same chunk.  Secondly, we place three chunks that
correspond to clause in all three leaves of their clausule gadgets. We
place in total $6 \cdot c$ variable chunks chunks this way.

We set number of spawned VMs to $cv + 2c$. Our intention is that in
every variable gadget there will lie $c$ VMs and in every of clause
gadgets there will lie $2$ VMs.

We set bandwidth for top edge of each variable gadget to:

$$ bw(v) = 3  \cdot  3  \cdot  (3  \cdot  (v - 1) + 2  \cdot  c) $$


First factor is distance on tree which is 6 divided by 2 (which is a
factor caused by counting every communication twice). Second factor is
number of VMs that spawn in every variable gadget. First compound of a
sum is 3 times number of outer variable gadgets. Second compound of a
sum is number of VMs that spawn in each of c clause gadgets.

We set bandwidth for top edge of each clause gadget to:

$$ bw(c) = 3  \cdot  2  \cdot  (2  \cdot  (c - 1) + 3  \cdot  v) $$

\textbf{Proof of correctness of the construction.}

\begin{lemma}
Exactly $c$ VMs are forced to spawn in every of $v$ variable gadgets
and exactly $2$ VMs are forced to spawn in every of $c$ clause gadgets
in every solution of cost $\leq Th$.
\end{lemma}

\begin{proof}
We show it by using bandwidth constraints. We have to take into
consideration following communication paths: (1) communication to
other variable gadgets; (2) communication to clause gadgets Extended
bandwidth lemma. In every solution of cost $\leq Th$ we have exactly
$c$ VMs in each variable gadget and $2$ VMs in each clause gadget.

\end{proof}

\begin{theorem}Constructed $VCB$ instance has solution of cost $\leq
  Th \iff \Formula \in 3SAT$.
\end{theorem}

\begin{proof}
($=>$) If we have a valuation, we fill variable gadgets with VMs like in
proofs before. Then we fill $2 \cdot c$ VMs in following way:

\begin{itemize}
\item if first literal satisfied the clause, we put $2$ VMs in second and
third leaf of clause gadget
\item if first literal not satisified the clause, we put $2$ VMs in first
and second leaf of clause gadget
\end{itemize}

We compute matching of chunks to VMs in the following way:
\begin{itemize}
\item chunk $c_i^1$ is matched to VM that sits in variable gadget; there
should be one like that, because the valuation satisfies
\item chunks $c_i^2$ and $c_i^3$ are matched to VMs that sit in clause
gadgets; there exists minimal-cost solution where VMs sit there
\end{itemize}

We produced feasible solution of cost $\Thr$, because there were no
transport and VMs communicated in predicted way.

($<=$) In order to finish the proof, we must prove the existance of
valuation that satisfies $\Formula$.
Let's take any solution $\Sol$ to $\VCNB_{\Formula}$ instance of cost $\leq \Thr$.

We create valuation Val in following way:
\begin{itemize}
\item $\Val(v) = T$ iff there lies VM on first leaf on positive side of $v$ gadget in $SOL$
\item $\Val(v) = F$ otherwise
\end{itemize}

\begin{lemma}For every clause there exist a VM in variable gadget that processes one of
  3 chunks that correspond to that clause.
\end{lemma}
\begin{proof}
 Every of $3$ chunks that correspond to every clause has machine sitting
on top of it. At least one of those $3$ is not idle in a variable gadget
- otherwise those two VMs in clause gadgets would not suffice in
satisfying all chunk types.\end{proof}

Observation. It might happen that in $SOL$ $2$ VMs in
clause variables are idle, and $3$ VMs in variable gadgets are
processing those $3$ chunk types, then we can take arbitrary in the rest
of the proof.


\begin{lemma}$\Val$ satisfies $\Formula$.
\end{lemma}
\begin{proof}
Let's take matching $M$ of $\Sol$. Let's take arbitrary clause of
$\Formula$ and its $3$ chunk types
: $c_i^1, c_i^2, c_i^3$. Let's name machines corresponding to them
to $vm_i^1, vm_i^2, vm_i^3$. Two of those lie in clause gadgets. Let's
take the chunk type that was processed in variable
gadgets and look at where it was processed. Look how was labeled the
leaf the VM lies. In our valuation Val we set this literal to have
value True. Therefore the clause is satisfied.
\end{proof}

This last lemma proves our theorem.
\end{proof}
\subsection{Images}

\begin{figure}[htbp]
\includegraphics[width = \columnwidth]{figs/gadget-no-bw}
\end{figure}


\begin{figure}[htbp]
\includegraphics[width = \columnwidth]{figs/vc-instance}
\end{figure}


\begin{figure}[htbp]
\includegraphics[width = \columnwidth]{figs/vc-instance-r2}
\end{figure}


\begin{figure}[htbp]
\includegraphics[width = \columnwidth]{figs/lemma-two-gadgets}
\end{figure}


\begin{figure}[htbp]
\includegraphics[width = \columnwidth]{figs/formula-example}
\end{figure}

