\subsection{Introduction and plan of this chapter}

In this chapter we will present two NP-completeness results: for all
model extensions combined: bw + cv + fp + r, and for last three model
extensions: cv + fp + r. In the rest of this chapter we will name
first problem as model with bandwidth and second problem as model
without bandwidth. First observation that we do is that model with
bandwidth is a generalization of the model without bandwidth and
therefore we need to only prove NP-completeness of model without
bandwidth. However, the approach we chose is to first show the proof
for model with bandwidth, as it is simpler and shares its structure
with proof for model without bandwidth, therefore being good
introduction. Also, in this introduction we can write more about ideas
of construction, leaving technical lemmas for the final proof.

\subsection{NP-completeness of model with bandwidth}

We decided to make reduction from Boolean Satisfiability problem (SAT)
to our Virtual Cluster problem with bandwidth (VCB). SAT is decision
problem, but VCB is optimization problem with NO answer
possible. Therefore to make those problems compatible in terms of
reduction, we consider decision VCB variant, in which instance we have
additional constant $Th$, and instance belongs to VCB if it has feasible
solution of cost $\leq Th$.

Let's remind what decision VCB variant instance consists of:
\begin{enumerate}
\item constant $Th$
\item balanced rooted tree $T$ with edge capacities $bw(e)$
\item constants $b_1$, $b_2$, which are costs of chunk transfer and
communication
\item constant $v$, which is desired number of VMs to be spawned
\item constant $ch$, which is number of types of chunks
\item sequence of chunks placed in leaves of $T$, possibly replicated
\end{enumerate}

Let's remind what SAT instance consists of:
\begin{enumerate}
\item clauses (let's name number of clauses as $cl(\Psi)$)
\item literals
\item variables (let's name number of variables as $var(\Psi)$
\end{enumerate}

Let's take any formula in Conjunctive Normal Form, name it $\Psi$ and produce
VCB instance $VCB_{\Psi}$. First, construct the tree $T_{\Psi}$. It will consist of
a root and separate gadget for each variable of $\Psi$, each of which
is a child of the root.


Gadget for variable $x$ has its root, $var(x)$, and two children:
$positive(x)$ and $negative(x)$. Vertex $positive(x)$ has $cl(\Psi)$
children: $x_1, x_2, \ldots, x_{cl(\Psi)}$. Vertex $negative(x)$ has
$cl(\Psi)$ children: $\neg x_1, \neg x_2, \dots, x_{cl(\Psi)}$. Every
gadget has the same structure: the same height, the same number of
leaves, and the same height. In fact, we will set bandwidth to be the
same everywhere in every gadget. Differences will be shown when we
will place data chunks.


We set number of virtual machines to spawn to $v = cl(\Psi) \cdot var(\Psi)$.

Now we will set cost of chunk transportation and cost of communication
among virtual machines. We set communication cost to be $1$. We set
trasportation cost to be $b_1 = W$, where $W$ is constant large enough
to disallow transportation. It means that if virtual machine wants to
process the chunk, it has to be spawned where the data chunk is
placed. Technically, transportation is not completely disallowed, it
just inclines cost so huge that every optimal solution has no
trasportation. TODO: We show how to compute $W$ in appendix.

Now we will set bandwidth constraints in $T_{\Psi}$. There are three
levels of edges in $T_{\Psi}$: top, middle and bottom. We set
bandwidth to unlimited at levels bottom and middle. At every edge of
top level, we set the same bandwidth to: $cl(\Psi) \cdot (var(\Psi) -
cl(\Psi))$. Idea behind capacity of this amount is that in every gadget we can
spawn at most $cl(\Psi)$ virtual machines. Let's prove it formally:

\begin{lemma} (bandwidth lemma)
  Let $c$ and $v > 4$ be positive natural numbers. Let $a_1, a_2, \ldots,
  a_v$ be natural number sequence that adds up to $c \cdot v$. Also, for
  each $i$ we have $a_i \leq 2 \cdot c$. Then, if we have this:

  $$ \forall_i a_i \cdot (c \cdot v - a_i) \leq c \cdot (c \cdot v -
  c) $$

  then each $a_i = c$.
\end{lemma}
\begin{proof}

Let's assume the contrary, which means that there exists such $y$ that
$a_y \neq c$. Then there are two cases: first, $a_y>c$ and second,
$a_y<c$. Proof for the first case is presented below; second case
with pidgeon hole principle results in existance of $a_z > c$, which
is basically the same (just substitute $a_y := a_z$ in proof below).

As we have $a_y < 2c$, we can say that $a_y$ has form $c +
k$ for $k \in [1, \ldots, c]$. Let's look at bandwidth inequality:

$$ (c + k) \cdot (c \cdot v - c - k) \leq c \cdot (c \cdot v - c) $$

After transforming it we have:

$$ 0 \leq k(k - (c \cdot (v - 2))) $$

Which is true for $k \leq 0$ or $k \geq c \cdot (v - 2)$, so no
positive $k \leq c$ can satisfy this inequality for $v > 4$, which gives a contradiction. 

\qed

\end{proof}

We will apply this lemma in following way. We interpret $a_i$ as
number of VMs that are spawned in $i$-th gadget. We set $c$ as number
of clauses and $v$ as number of variables. LHS of inequality from the
lemma is formula for communication cost of machines inside $i$-th
gadget to machines outside the gadget. RHS of the inequality is
bandwidth constraint for the gadget. Corollary from the lemma is that
any feasible solution must place exactly $c$ machines in every gadget.

TODO: We need to consider case where $v \leq 4$. First of all, it is
finite case, so we can do it by hand. We need to
produce an instance anyway though.

We set number of chunk types to be equal to number of clauses, $ch =
c(\Psi)$. To finish construction of $T_{\Psi}$, we need to place data chunks in
leaves. We do it the following way. For each clause of number $i$ we
construct as many replicas of chunk $c_i$ as there are literals in
clause $i$. For each literal $l$ (of form $v$ or $\neg v$) that satisfies clause $i$ we place
replica of chunk $c_i$ in leaf labeled $c_{l_i}$. TODO: draw example for
some simple formula.

To finish our construction, we need to set value of constant $Th$. We
do it by calculating communication cost among spawned virtual machines in
certain solution to our instance. This soulution is constructed by placing
virtual machines in all leaves of $positive(v)$ and none in leaves
$negative(v)$ for every gadget for variable $v$. Please note that $Th$
computed such way do not contain transportation cost. We will prove it
more formally in proof of model without bandwidth.

With our construction completed, we need to prove that it indeed
decides SAT.

\begin{theorem}Formula $\Psi$ is satisfiable iff $VCB_{\Psi}$ has
solution of cost $\leq Th$.
\end{theorem}

\begin{proof}
($=>$) Let's take any valuation $F$ that satisfies $\Psi$. We will construct
solution to $VCB_{\Psi}$ using F in the following way. For each
variable $v \in var(\Psi)$ we place $cl(\Psi)$ virtual machines in
leaves of gadget $var(v)$. We need to choose $cl(\Psi)$ out of
$2 \cdot cl(\Psi)$ leaves to spawn VMs. If $F(v) = 1$, we spawn all VMs in leaves
of $positive(v)$, else we spawn all VMs in leaves of
$negative(v)$. Solution constructed such way has cost exactly
$Th$, because VMs are evenly splitted among gadgets and VMs are not
mixed between $positive(v)$ and $negative(v)$ subtrees. We will prove
this claim in more detail in next proof. 

($<=$) Let's take any solution to $VCB_{\Psi}$ of cost $\leq Th$. We
will construct valuation $F$ using placement of virtual machines in
solution to $VCB_{\Psi}$.

We need to take following observations. In every solution of cost
$\leq Th$ every gadget has exactly $ch(\Psi)$ VMs spawned in its
leaves. It is true because we proved the bandwidth lemma. Also, inside
every gadget either all VMs are spawned in $positive(v)$ or all VMs
are spawned in $negative(v)$. It is true because cost of solution
where at least one gadget has VMs mixed between those branches is
always greater than $Th$. TODO: prove it more formally.

Now we can construct our valuation $F$. We do it the following way
(for each $v \in var(\Psi)$:

\begin{itemize}
\item if $v_1$ has machine in it then $F(v) = true$
\item otherwise $F(v) = false$
\end{itemize}

Valuation $F$ satisfies $\Psi$ because it satisfies every clauses, as
$VCB_{\Psi}$ solution processed all the chunks. No transportation of
chunks is allowed. Also, we have the property that if there is a VM in
$positive(v)$ subtree of any gadget, then:

\begin{enumerate}
\item every other leaf in $positive(v)$ has VM spawned in it
\item no leaf in $negative(v)$ has VM spawned in it
\end{enumerate}

\end{proof}

\subsection{NP-hardness of model without bandwidth}

There were only one use of bandwidth in proof from previous
chapter. It was to control number of VMs spawned in every gadget. For
model without bandwidth we need some other mechanism to control
it. Our high-level plan is like that:
\begin{enumerate}
\item Do not touch structure of previous proof.
\item Show new gadget for a variable.
\item Place new types of chunks in a tree.
\item Adjust number of VMs to spawn to work with new gadget.
\item Calculate new constant $Thr$ (as threshold).
\item Prove observations from previous proof. 
\end{enumerate}

Structure of construction is essentially untouched. We take any
formula $\Psi$ and construct instance of model without bandwidth,
$VC_{\Psi}$ that has solution of cost $\leq Th$ iff $\Psi$ is
satisfiable. Our tree once again consists of gadgets for each
variable. Once again, we will have correspondence between clauses and
chunk types $c_1, c_2, c_{cl(\Psi)}$ (so called clause chunks). 

Definition 1. Solution $S$ is semi-feasible iff. 

\begin{figure}[htbp]
\includegraphics[width = \columnwidth]{figs/gadget-no-bw.pdf}
\end{figure}


\begin{figure}[htbp]
\includegraphics[width = \columnwidth]{figs/vc-instance.pdf}
\end{figure}


\begin{figure}[htbp]
\includegraphics[width = \columnwidth]{figs/vc-instance-r2.pdf}
\end{figure}


\begin{figure}[htbp]
\includegraphics[width = \columnwidth]{figs/lemma-two-gadgets.pdf}
\end{figure}


\begin{figure}[htbp]
\includegraphics[width = \columnwidth]{figs/formula-example.pdf}
\end{figure}




\subsection{NP-completeness of model with bandwidth and replication of
  degree 2.
}
Plan:

\begin{itemize}
\item modify cv+fp+bw+r proof
\item from $3SAT$
\item each variable occurence is alone chunk
\item we construct the tree from two types of gadgets:
(a) gadgets $V$ for variables
(b) gadgets $C$ for clauses
\item all $3$ chunks that correspond to the same clause are groupped in
clause gadget  
\item in variable gadgets: $x \oplus \neg x$ is forced by bandwidth constraints
and VMs being on one side in cheapest semi-feasible solution
\item let $c=cl(\Psi)$, $v=var(\Psi)$
\item we plan on putting $vms = v  \cdot  c + 2  \cdot  c$
\item on number of leaves being $l = 2 \cdot v \cdot c + 3 \cdot c$

\end{itemize}

The idea is to reduce from 3SAT using only replication of degree
2. How can we simulate this behavior using only two replicas?

First, we traverse literals of $\Psi$ one by one and put $3 \cdot c$ chunks in
variable gadgets. Depending on being positive or negative, we place
chunk either in positive(v) or negative(v) subtree on $v_i$, where $i$ is
number of clause that currently traversed literal lies.

Secondly, we place chunks that correspond to clauses in their clausule
gadgets. We place $3 \cdot c$ chunks there.

We set number of spawned VMs to $cv + 2c$ in following way that:

\begin{itemize}
\item $c$ VMs are forced to spawn in every of $v$ variable gadgets
\item $2$ VMs are forced to spawn in every of $c$ clause gadgets
\end{itemize}

We force it by setting bandwidth constraints. We have to take into
consideration following communication paths: (1) communication to other variable gadgets; (2) communication to clause gadgets

We set bandwidth for top edge of each variable gadget to:

$$ bw(v) = 3  \cdot  3  \cdot  (3  \cdot  (v - 1) + 2  \cdot  c) $$


First factor is distance on tree which is 6 divided by 2 (which is a
factor caused by counting every communication twice). Second factor is
number of VMs that spawn in every variable gadget. First compound of a
sum is 3 times number of outer variable gadgets. Second compound of a
sum is number of VMs that spawn in each of c clause gadgets.


We set bandwidth for top edge of each clause gadget to:

$$ bw(c) = 3  \cdot  2  \cdot  (2  \cdot  (c - 1) + 3  \cdot  v) $$

Extended bandwidth lemma. In every solution of cost $\leq Th$ we have
exactly $c$ VMs in each variable gadget and $2$ VMs in each clause gadget.

Why it decides $3SAT$?

If we have a valuation, we fill variable gadgets with VMs like in
proofs before. Then we fill $2 \cdot c$ VMs in following way:

\begin{itemize}
\item if first literal satisfied the clause, we put $2$ VMs in second and
third leaf of clause gadget
\item if first literal not satisified the clause, we put $2$ VMs in first
and second leaf of clause gadget
\end{itemize}

We compute matching of chunks to VMs in the following way:
\begin{itemize}
\item chunk $c_i^1$ is matched to VM that sits in variable gadget; there
should be one like that, because the valuation satisfies
\item chunks $c_i^2$ and $c_i^3$ are matched to VMs that sit in clause
gadgets; there exists minimal-cost solution where VMs sit there
\end{itemize}

We produced feasible solution of cost $Th$, because there were no
transport and VMs communicated in predicted way.

In order to finish the proof, we must prove the existance of
valuation that satisfies $\Phi$. 
Let's take any solution $SOL$ to $VC_{\Psi}$ instance of cost $\leq Th$.

We create valuation Val in following way:
\begin{itemize}
\item $Val(v) = T$ iff there lies VM on first leaf on positive side of $v$ gadget in $SOL$
\item $Val(v) = F$ otherwise
\end{itemize}

\begin{lemma}For every clause there exist a VM in variable gadget that processes one of
  3 chunks that correspond to that clause.
\end{lemma}
\begin{proof}
 Every of $3$ chunks that correspond to every clause has machine sitting
on top of it. At least one of those $3$ is not idle in a variable gadget
- otherwise those two VMs in clause gadgets would not suffice in
satisfying all chunk types. It might happen that in $SOL$ $2$ VMs in
clause variables are idle, and $3$ VMs in variable gadgets are
processing those $3$ chunk types, then we can take arbitrary in the rest
of the proof.
\end{proof}

\begin{lemma}$Val$ satisfies $\Psi$.
\end{lemma}
\begin{proof}
Let's take matching $M$ of $SOL$. Let's traverse it $3$ chunk types at a
time: $c_i^1, c_i^2, c_i^3$. Let's name machines corresponding to them
to $vm_i^1, vm_i^2, vm_i^3$. Two of those lie in clause gadgets. Let's
take the chunk type that was processed in variable
gadgets and look at where it was processed. Look how was labeled the
leaf the VM lies. In our valuation Val we set this literal to have
value True. Therefore $i$-th clause is satisfied.
\end{proof}