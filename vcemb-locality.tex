\documentclass[9pt,twocolumn]{scrartcl}

%\documentclass[9pt]{sigcomm-alternate}

%\usepackage[margin=1in,bottom=1.2in]{geometry}
\usepackage{amsfonts,amssymb,amsmath}
\usepackage[thmmarks,hyperref,amsthm,amsmath]{ntheorem}
\usepackage{graphicx}
\usepackage[ruled,vlined,commentsnumbered]{algorithm2e}
\usepackage[usenames,dvipsnames]{color}
\usepackage{hyperref}
\usepackage{multirow}
\usepackage{lineno}
\usepackage[shortlabels]{enumitem}
\usepackage[utf8]{inputenc}
\usepackage[OT4]{fontenc}
\usepackage{comment}
\usepackage{fancyhdr}
\usepackage{tikz}
%Used Symbols
%c_i = chunk i
%v_i = vm i
%b_t = transfer bandwidth
%b_c = pairwise communication bandwidth
%n = |VMs| = |Chunks|


%Header Extensions Seperation
%Carlo
\newcommand{\Capacity}{\ensuremath{\textsc{cap}}}
\newcommand{\VM}{\textsc{VM}}
\newcommand{\Chunk}{\ensuremath{c}}
\newcommand{\Problem}{\textsc{DummyName Problem}}
\newcommand{\carlo}[1]{\textcolor{red}{#1}}
\newcommand{\maciek}[1]{\textcolor{green}{#1}}
\newcommand{\MaFactor}{\ensuremath{\textsc{MA}}}
\newcommand{\Path}{\ensuremath{p}}
\newcommand{\RedundancyFactor}{\ensuremath{r}}

\newcommand{\VmChunkAssignment}{\ensuremath{ASS_v}}
\newcommand{\NodeMapping}{\ensuremath{MAP_v}}
\newcommand{\ChunkLocation}{\ensuremath{\textsc{loc}}}

\newcommand{\ChunkType}{\ensuremath{textsc{ct}}}
\newcommand{\VirtualNodes}{\ensuremath{V_V}}
\newcommand{\VirtualEdges}{\ensuremath{E_V}}
\newcommand{\VirtualNode}{\ensuremath{v}}
\newcommand{\VirtualEdge}{\ensuremath{e}}
\newcommand{\VCSwitch}{\ensuremath{\textsc{center}}}
\newcommand{\SubstrateNodes}{\ensuremath{V_S}}
\newcommand{\SubstrateEdges}{\ensuremath{E_S}}
\newcommand{\SubstrateNode}{\ensuremath{v}}
\newcommand{\SubstrateEdge}{\ensuremath{e}}
\newcommand{\Leaf}{\ensuremath{l}}
\newcommand{\Leaves}{\ensuremath{L}}
\newcommand{\Chunks}{\ensuremath{\textsc{chunks}}}
\newcommand{\aroot}{\emph{root}}

\newcommand{\clauses}{\alpha}
\newcommand{\vars}{\beta}
\newcommand{\variables}{\beta}
\newcommand{\achunk}{c}
\newcommand{\capa}{\emph{capacity}}

\newcommand{\VC}{\textsc{VC}}
\newcommand{\CC}{\textsc{CC}}

\newcommand{\VE}{\textsc{VE}}
\newcommand{\FP}{\textsc{FP}}
\newcommand{\RS}{\textsc{RS}}
\newcommand{\BW}{\textsc{BW}}
\newcommand{\MA}{\textsc{MA}}
\newcommand{\Cost}{\textsc{Cost}}

\newcommand{\MatchCost}{\textsc{MCost}}
\newcommand{\chunkOf}{\textsc{chunkOf}}


%Maciek

\newcommand{\Bandwidth}{\ensuremath{bw}}
\newcommand{\Tree}{\ensuremath{T}}
\newcommand{\CostCom}{\ensuremath{b_1}}
\newcommand{\CostTrans}{\ensuremath{b_2}}
\newcommand{\Vms}{\ensuremath{n}}
\newcommand{\TSC}{\textsc{3-SC}}
\newcommand{\TDM}{\textsc{3-DM}}
\newcommand{\TSAT}{\textsc{3-Sat}}
\newcommand{\NSAT}{\textsc{Sat}}
\newcommand{\SAT}{\textsc{Sat}}
\newcommand{\ZSAT}{\textsc{2-Sat}}


\newcommand{\Formula}{\ensuremath{\Psi}}
\newcommand{\Clauses}{\ensuremath{Cl(\Formula)}}
\newcommand{\NClauses}{\ensuremath{c}}
\newcommand{\Vars}{\ensuremath{Var(\Formula)}}
\newcommand{\NVars}{\ensuremath{|\Vars|}}
\newcommand{\ChunkTypes}{\ensuremath{ch}}
\newcommand{\Thr}{\ensuremath{Th}}
\newcommand{\VCB}{\ensuremath{VCB}}
\newcommand{\VCNB}{\ensuremath{VCNB}}
\newcommand{\varx}{\ensuremath{x}}
\newcommand{\positive}{\ensuremath{positive}}
\newcommand{\negative}{\ensuremath{negative}}
\newcommand{\Val}{\ensuremath{Val}}
\newcommand{\Sol}{\ensuremath{SOL}}



\definecolor{blueLink}{rgb}{0,0.2,0.8}
\hypersetup{colorlinks,linkcolor=blueLink,urlcolor=blueLink,citecolor=blueLink}
\newcommand{\lref}[2][]{\hyperref[#2]{#1~\ref*{#2}}}



\input{macros}

\title{A Note on Virtual Cluster Embedding with Data Locality}

\title{Embedding Algorithms for Virtual Clusters with Data Locality and Replica Selection}

\title{Embedding Virtual Clusters with Data Locality and Replica Selection\\{\Large Real Algorithms for Virtual Environments}}

\title{Data Locality and Replica Aware Virtual Cluster Embeddings for Fat-Trees\\{\Large Real Algorithms for Virtual Environments}}


\author{Carlo Fuerst$^1$, Maciek Pacut$^2$, Stefan Schmid$^3$\\
$^1$ TU Berlin, Germany; $^2$ University of Wroclaw, Poland; $^3$ TU Berlin \& T-Labs, Germany}

\begin{document}

\maketitle


\begin{abstract}
\textbf{Abstract.} Virtualized datacenters offer great flexibilities in terms of resource allocation. In particular, by
decoupling applications from the constraints of the underlying physical infrastructure, virtualization
supports an optimized mapping of virtual machines as well as their interconnecting network (the so-called \emph{virtual cluster}) to their
physical counterparts: essentially a graph embedding problem.

However, existing algorithms
in the literature often ignore a crucial dimension of the embedding problem, namely \emph{data locality}:
the input to a cloud application such as MapReduce is typically stored in a distributed,
and sometimes redundant, file system or database. Since moving this data is costly, an embedding algorithm should be data locality aware,
and allocate computation close to the data; in case of redundant storage, the algorithm should also optimize the \emph{replica selection}.

This paper initiates the algorithmic study of data locality aware virtual cluster embeddings in fat-tree like datacenter topologies.
In particular, we
show that
despite the many degrees of freedom of the embedding, many problems can be
solved efficiently, and we highlight interesting connections
to classic optimization problems, such as matchings
flow problems. However, we also show the limitations of such optimizations,
by presenting several new NP-hardness results; interestingly,
our hardness proofs are for uncapacitated settings.
\end{abstract}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Introduction}

Server virtualization has revamped the server business over the last years,
and has radically changed the way we think about resource allocation:
today, almost arbitrary computational resources can be allocated on demand.
Moreover, the virtualization trend now started to spill over to the network:
batch-processing applications such as MapReduce often generate significant
network traffic (namely during the so-called shuffle phase)~\cite{amazonbw},
and in order to avoid interference in the underlying physical network and in order to provide a predictable
application performance, it is important to provide performance isolation and bandwidth guarantees
for the virtual network connecting the virtual machines.~\cite{talk-about}

Server and network virtualization introduces interesting resource allocation flexibilities,
in the sense that virtual machines and their interconnecting network,
can in principle be embedded \emph{anywhere} in the datacenter. The resulting flexibilities
can be exploited for various optimizations;
however, the joint optimization of node and link mapping is often non-trivial.~\cite{pb-embed}
Over the last years, especially the problem of embedding
\emph{Virtual Clusters} has been studied intensively. Virtual clusters are the most popular abstraction for batch-processing applications:
a virtual cluster connects a set of virtual machines by providing pair-wise bandwidth guarantees.
In order to provide resource-efficiency, existing algorithms aim to map virtual machines as close as possible
in the datacenter, which minimizes communication costs.~\cite{oktopus,proteus}

However, existing embedding algorithms often ignore an important aspect: the fact that the input data
to batch-processing applications,
the so-called \emph{chunks}, are stored in a distributed file system or database. In order to minimize
costly data transmissions, an embedding algorithm should be \emph{data locality aware},
and map compute units close to the chunk locations. Moreover, in case of redundant storage (batch processing
applications often provide a 3-fold redundancy), the algorithm should exploit flexibilities in
the \emph{(chunk) replica selection}.

\subsection{Our Contributions}

This paper initiates the study of data-locality and replica aware embedding problems in virtualized datacenters.
In particular, we decompose the optimization problem into different fundamental models, in terms of flexible
node placement, capacity constraints, or replication,
and draw an almost complete picture of the problem space. Concretely, we show that several problems
can be solved optimally in polynomial time, despite the large degrees of freedom, and also highlight
computational hardness limitations. Interestingly, while it is well-known that (unsplittable) multi-commodity flow
problems are NP-hard in capacitated networks, our results highlight the hardness of several uncapacitated
optimization problems. In particular, we show that NP-hard problems already arise in trees of height two,
and even if the number of replicas is bounded by two.


\subsection{Organization}

The remainder of this paper is organized as follows.
Section~\ref{sec:model} introduces our formal model in detail.
Algorithms are presented in Section~\ref{sec:poly} and
hardness results are presented in Section~\ref{sec:np}.
After discussing related work in Section~\ref{sec:relwork},
we conclude our work in Section~\ref{sec:conclusion}.


\section{Model}\label{sec:model}

We will first present our model formally, and subsequently discuss how it relates
to batch-processing applications.

\textbf{Fundamental Parts.} Our model consists of three fundamental parts: (1) the substrate network,
(2) the input data, and
(3) the virtual network.
The substrate network (also known as the \emph{host graph}) describes the physical resources: the servers
and the inter-connecting datacenter topology.
We assume that servers have a certain capacity, in terms of the number of virtual machines or compute units they
can host. The servers are interconnected by a tree network. Concretely, we assume a tree network
$G=(V,E)$ where $V=S \cup R$ describes the set $S$ of servers (located at the leaves) which are inter-connected
via routers (or switches) $R$ by links $E$.
The problem input is stored in the form of \emph{chunks} which are distributed across the servers;
chunks may be redundant.
The virtual network consists of virtual machines (henceforth often simply called \emph{nodes}) which need to be mapped to substrate servers.
Since these virtual machines process the input data, they need to be assigned and connected to the
chunks; each virtual machine should be assigned the same number of chunks (up to rounding issues if
the number of chunks is not a perfect multiple of the number of virtual machines). Moreover, virtual machines need to be connected among each other.
In order to provide performance guarantees, both the connection to the chunks
as well as the interconnection between the virtual machines must provide a certain
minimal bandwidth guarantee; we will refer to the first type of network as the \emph{access
network}, and to the second type of network as the \emph{inter-connect}. The inter-connect will
is modelled as a complete network (a virtual cluster).

TODO: if we ever want to put 2 replica NP-completeness proof, we need to introduce idle machines 

FIXME: introduce formal concepts

\textbf{Optimization Objective.} Our goal is to develop algorithms which minimize
the resource footprint: the overall bandwidth allocation in the datacenter. That is,
we aim to embed virtual machines close to the input data as well as close to
each other.

FIXME: add an overview picture

\textbf{Problem Decomposition.}
In order to provide a complete picture of the tractability and intractability of different
problem variants, we decompose our problem into its fundamental aspects.
First, we distinguish between an uncapacitated and a capacitated scenario where the links of the substrate network come with bandwidth
constraints, and will refer to the bandwidth-constrained version by $\BW$.
Second, we distinguish whether the virtual machines only need to be connected to the chunks, or also
among each other; we will refer to the model where an inter-connect is required
by $\CC$.
Third, we will distinguish whether data is stored redundantly or not; we will refer to the variant
with replica selection, i.e., where the algorithm can choose from multiple replicas, by $\RS$.
We also distinguish between a scenario where multiple chunks need to be assigned to a node
(called $\MA$), and one where there are less chunks than virtual machines.
Finally, we note that in scenarios with replicated input, the problem of assigning replicas
to nodes is already interesting if the location of nodes is \emph{given} and cannot be optimized,
we distinguish between a scenario where the node placement is flexible (called $\FP$) and one where
it is not.

\textbf{Remark on Practical Motivation.}
Our model is inspired by batch-processing applications such as MapReduce.
The standard datacenter topology today are fat-trees~\cite{fattree},
and the most popular virtual network abstraction is the virtual cluster~\cite{oktopus}.
MapReduce applications cycle through three main phases: during the first phase,
the input data is mapped in a distributed fashion, by the mappers.
The resulting output is then transmitted to the so-called reducers; this phase is
called the shuffling phase. In the third phase, the data is processed by the reducers.
Moreover, in the beginning resp.~in the end, data needs to be loaded from resp.~written
back to the distributed file system.
Typically, a node serves both as a mapper and a reducer.

In our formal model, we distinguish between the bandwidth $b_1$ needed to
transmit the input data to its assigned node, and the bandwidth $b_2$
needed during the shuffling phase between the virtual nodes.
The ratio $b_1/b_2$ can be seen as the so-called mapping ratio:
how much smaller is the input after the mapping phase.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\section{Algorithms}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Carlo Model (to be merged by STefan later)}
\input{models}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Polynomial-Time Algorithms}\label{sec:poly}

Our data locality and replica aware virtual cluster embeddings
problem exhibits interesting connections to classic matching and
flow problems. In this section, we point out these connections and
exploit them to devise polynomial-time algorithms for a wide range
of problem variants. We also show that a large number of problems
can be solved optimally using dynamic programming. Note that all proposed 
algorithms solve the problem optimally w.r.t. to the overall bandwidth costs 
independently of $\CostTrans$ and (if present in the properties) $\CostCom$ and 
$\Capacity$

\input{matching}

\input{flow}

%\subsection{Dynamic programming solution}
\input{dynamic_embedding}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{NP-Hardness Results}\label{sec:np}

\input{np-completeness}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Related Work}\label{sec:relwork}

Our work is motivated by the resource allocation and computational model of
batch-processing cloud applications, such as MapReduce. 
These applications 
generate large amounts of network traffic, and a considerable
fraction of the runtime is due to network acti\-vi\-ty.~\cite{talk-about,amazonbw,orchestra}.
Accordingly, systems have been proposed which provide
a provable network performance by making explicit bandwidth reservations
between the virtual machines or compute units, either relative~\cite{seawall,faircloud,elasticswitch} 
or absolute~\cite{secondnet,oktopus, proteus, drl, gatekeeper}. 

The need to take into account both node as well as link resources motivates
the design of virtual networks, and the question of how to efficiently embed virtual networks
has been studied intensively, also from an algorithmic perspective.
For a good survey on network virtualization and in particular virtual network embeddings,
we refer the reader to~\cite{boutaba-survey} and~\cite{fischer-survey}.

The most popular abstraction for batch-processing applications is the virtual cluster,
introduced in the Oktopus paper~\cite{oktopus}, and later studied by many other researchers~\cite{proteus}. 
Many heuristics have been developed to compute ``good'' embeddings of virtual clusters, in the sense that
they result in small footprints (minimal bandwidth reservation costs). 

However, the virtual network embedding problem has not only been studied for virtual clusters,
but also for more general graphs (motivated by wide-area networks). In contrast to the classic VPN 
graph embedding problems~\cite{gupta2001provisioning,Goyal2008},
in these models, also the embedding endpoints are flexible and subject to optimization. 
In this respect, the problem can also be seen as a generalization of the classic NP-hard Minimum Linear Arrangement problem which asks for the
embedding of guest graphs on a simple line topology.~\cite{mla,mla-survey,mla-feige}
Indeed, many problem variants are NP-hard and much research so far has focused on heuristics~\cite{ammar,zhu06,simannealing,turner}
or mixed integer programs~\cite{infocom2009,ucc12mip}.

However, to the best of our knowledge, we are the first to provide an algorithmic
study of the cloud application embedding problem which also takes into account
data locality as well as the possibility to select replicas. As we have shown in this paper,
the resulting problems can be seen as interesting new variants of several classic optimization
problems, such as hitting sets, matchings and 3-dimensional matchings~\cite{3SC-hard} as well as cover and flow problems.~\cite{korte2002combinatorial}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Summary and Conclusion}\label{sec:conclusion}

This paper investigated two fundamental new dimensions of virtual cluster
embedding problems: data locality and replica selection. We pursued
an algorithmic approach and decomposed the problem into fundamental aspects,
namely $\BW$, $\CC$, $\RS$, $\MA$ and $\FP$. Our results are summarized in
Figure~\ref{fig:summary}. 
In particular, we have shown that
at the heart of our problem lie interesting new variants of classic
optimization problems related to matchings and flows. Interestingly, despite the
numerous
flexibilities, many problem instances can actually be solved in polynomial time.
On the negative side, we have also shown that there exist computationally hard
problems even in uncapacitated networks. In particular,
we have shown that several embeddings problems are NP-hard already in two-level fat-trees (practically speaking:
problems inside a single \emph{pod}), and even if the the number of replicas is bounded by two.


\begin{figure}[t]
\includegraphics[width = \columnwidth]{figs/summary}
\caption{Summary of results. As this paper only presented algorithms for the most
difficult problems and, respectively, proved NP-hardness of the simplest
problems, several additional results are simple implications (indicated by arrows).}
\label{fig:summary}
\end{figure}


Our paper provides an almost complete overview of what can and cannot be
computed optimally in our setting, and may of interest both to the algorithm
and the networking community. However, our work also opens several interesting
questions for future research, for instance, regarding randomized algorithms
or approximation algorithms. A concrete and particularly interesting open
question is whether FIXME.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\bibliographystyle{alpha}
\bibliography{references}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{appendix}


\section{Bandwidth Lemma}

The following lemma is useful in our NP-hardness proofs.

\begin{lemma}[Bandwidth Lemma]\label{lem:bandwidth-lemma}
  Let $c$ and $v > 4$ be two arbitrary positive integers. Let $a_1, a_2, \ldots,
  a_v$ be a sequence of $v$ integers which adds up to $c \cdot v$. Also, for
  each $i$ we have $a_i \leq 2 \cdot c$. Then it holds that if 
  $$ \forall_i a_i \cdot (c \cdot v - a_i) \leq c \cdot (c \cdot v -
  c), $$
\noindent  then for each $i$, $a_i = c$.
\end{lemma}
\begin{proof}
For the sake of contradiction, let us assume that there exists an index $k$ such that
$a_k \neq c$. Then we can distinguish between two cases: 
either $a_k<c$ or
$a_k>c$. 

\textbf{Case $a_k<c$:} If there exists a $k$ with $a_k<c$,
due to the fact that the sequence sum adds up to $c \cdot v$,
there must also exist a $k'$ such that $a_{k'}<c$ (by a simple
pigeon hole principle). Thus, this case can
also be reduced to the second case (\textbf{Case $a_k>c$}) proved
next

\textbf{Case $a_k>c$:} Since it also holds that $a_k < 2c$, 
$a_k$ must be of the form $c + x$ for $x \in [1, \ldots, c]$. 
Let us consider the (bandwidth) inequality:
$$ (c + x) \cdot (c \cdot v - c - x) \leq c \cdot (c \cdot v - x) $$

This can be transformed to:

$$ 0 \leq x(x - (c \cdot (v - 2))) $$

The equation holds for $x \leq 0$ or $x \geq c \cdot (v - 2)$, 
and no 
positive $x \leq c$ can satisfy this inequality for $v > 4$. Contradiction.
\end{proof}


\section{Capacities are hard ($\RS+\FP+\BW$)}

We prove that $\RS+\FP+\BW$ is NP-hard by reduction from the Boolean Satisfiability Problem ($\SAT$).
Since $\SAT$ is a decision
problem, we transform $\RS+\FP+\BW$ into a decision problem too, by
introducing a cost threshold $\Thr$.

Let's first recall that the $\SAT$ problem asks whether a positive valuation exists
for a formula $\Formula$ with $\clauses$ clauses and $\variables$ variables.
In the following, we will only focus on $\SAT$ instances of at least four variables;
this problem remains NP-hard.

\textbf{Construction.}
Given any formula $\Formula$ in Conjunctive Normal Form (CNF) with at least four variables, we produce
a $\RS+\FP+\BW$ instance as follows. First, we construct a substrate tree $\Tree_{\Formula}$, consisting of
a root and separate gadgets for each variable of $\Formula$, each of which
is a child of the root.
The gadget of variable $v$ has a root, $\aroot(v)$, and two children:
$\positive(v)$ and $\negative(v)$. Vertex $\positive(v)$ has $\clauses$
many children $v_1, v_2, \ldots, v_{\clauses}$, and vertex $\negative(v)$ has
$\clauses$ many children $\neg v_1, \neg v_2, \dots, v_{\clauses}$. Every
gadget has the same structure: the same height and the same number of
leaves. By default, we will set the available bandwidth to be the
same everywhere, in every gadget; differences will be shown when we
will place chunks.

We set the number of virtual machines to $n = \clauses \cdot \variables$.
Moreover, we define the inter-connect communication cost to be $1$,
and the access cost to be a sufficiently large constant $W$,
such that nodes must always be collocated with chunks.
(For a concrete value, use $W=$TODO).


We set the following bandwidth capacities in the substrate. There are three
levels of edges in the substrate tree $\Tree_{\Formula}$ given by formula
$\Formula$: \emph{top}, \emph{middle} and \emph{bottom}.
We do not consider any capacities at the \emph{bottom} and \emph{middle} levels.
At a top-level edge, we set the bandwidth to $\clauses \cdot (\variables -
\clauses)$.

We set the number of chunks to be equal to the number of clauses, $\ChunkTypes =
\clauses$. To finish our construction, we place data chunks at
leaves, as follows: for the $i$-th clause we
construct as many replicas of chunk $\achunk_i$ as there are literals in the
clause. For each literal $\ell$ (of the form $v$ or $\neg v$) that satisfies clause $i$ we place
replica of chunk $\achunk_i$ in leaf labeled $\achunk_{\ell_i}$.

The threshold $\Thr$ is given by the
communication cost among nodes in
a certain solution to our instance. This solution is constructed by embedding
nodes at all leaves of $\positive(v)$ and none at leaves
$\negative(v)$, for every gadget for variable $v$. Please note that $\Thr$
computed such way do not contain transportation cost. TODO: calculate
$\Thr$.

\textbf{Proof of correctness of construction.}
With our construction completed, we need to prove that it indeed
decides $\SAT$. We set the capacities such that in every gadget,
at most $\clauses$ nodes can be spawned, where $\clauses$
is the number of clauses of $\Formula$.
We can apply the Bandwidth Lemma (Lemma~\ref{lem:bandwidth-lemma}) as follows:
We interpret $a_i$ as the
number of nodes that are embedded in the $i$-th gadget; we set $c=\clauses$ 
to be the number
of clauses and $v=\variables$ to be the number of variables. 
The LHS of the inequality of Lemma~\ref{lem:bandwidth-lemma}
is a formula for the communication cost of nodes inside the $i$-th
gadget to nodes outside the gadget. The RHS of the inequality is the
bandwidth constraint for the gadget. This implies that
any feasible solution must embed exactly $c$ nodes in every gadget.


\begin{theorem}
The problem $\RS+\FP+\BW+\CC$ is NP-hard.
\end{theorem}
\begin{proof}
We will prove that formula $\Formula$ is satisfiable iff $\RS+\FP+\BW+\CC$ has
solution of cost $\leq \Thr$.

($\Rightarrow$) Let's take any valuation $\Val$ that satisfies $\Formula$. 
We will construct a solution to $\RS+\FP+\BW$ using $\Val$ in the following way. 
For each variable $v$ in $\Formula$, we embed $\clauses$ many virtual machines 
at the  leaves of the gadget of $v$. We need to choose $\clauses$ out of
$2 \cdot \clauses$ leaves to embed nodes. If $\Val(v) = 1$, we embed
nodes at the leaves
of $\positive(v)$, else we embed all nodes at leaves $\negative(v)$. 
The solution constructed this way has cost exactly
$\Thr$, because the nodes are evenly split among gadgets, and nodes are not
distributed across $\positive(v)$ and $\negative(v)$ subtrees.

We calculate the matching of chunks to VMs by matching every chunk to
VM that sits on top of first chunk replica. This solution is feasible
(every chunk type is processed) basically
because given valuation satisfied the $\Phi$.

Now we will show that this solution has cost $\Thr$. 
Due to the Bandwidth Lemma (Lemma~\ref{lem:bandwidth-lemma}),
we only have to consider the communication cost. 

($\Leftarrow$) Let's take any solution to $\RS+\FP+\BW$ constructed based on $\Formula$ of cost $\leq \Thr$. 
We will construct a positive valuation $\Val$ by considering the nodes in
the solution to $\RS+\FP+\BW$.

We make the following observations. In every solution of cost
$\leq \Thr$, every gadget has exactly $\clauses$ many nodes 
at its leaves. This is due to the Bandwidth Lemma. Also, inside
every gadget either all nodes are in the $\positive(v)$ subtree
of variable $v$, or in the $\negative(v)$ subtree. This is true 
because the cost of a solution where at least one gadget has nodes
distributed across subtrees is
always greater than $\Thr$.

TODO Maciek: prove it more formally. First, define semi-feasible solution. Let's take any $p,q$ being the number of nodes
spawned in left and right subtree. Then we say that we can improve the
solution by moving all $q$ to where $p$s lie and we have cheaper solution.

Now we can construct our valuation $\Val$, as follows 
(for each variable $v$ in $\Formula$):
If $v_1$ hosts a node then $\Val(v) = \top$, 
otherwise $\Val(v) = \bot$.

The valuation $\Val$ satisfies all clauses, and hence $\Formula$,
as the solution to $\RS+\FP+\BW$ covers all chunks. To see this,
consider the leaf handling any given clause chunk;
it is a witness that the corresponding clause is true.
\end{proof}


\end{appendix}


\end{document}
