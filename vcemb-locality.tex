\documentclass[9pt,twocolumn]{scrartcl}

%\documentclass[9pt]{sigcomm-alternate}

%\usepackage[margin=1in,bottom=1.2in]{geometry}
\usepackage{amsfonts,amssymb,amsmath}
\usepackage[thmmarks,hyperref,amsthm,amsmath]{ntheorem}
\usepackage{graphicx}
\usepackage[ruled,vlined,commentsnumbered]{algorithm2e}
\usepackage[usenames,dvipsnames]{color}
\usepackage{hyperref}
\usepackage{multirow}
\usepackage{lineno}
\usepackage[shortlabels]{enumitem}
\usepackage[utf8]{inputenc}
\usepackage[OT4]{fontenc}
\usepackage{comment}
\usepackage{fancyhdr}
\usepackage{tikz}
%Used Symbols
%c_i = chunk i
%v_i = vm i
%b_t = transfer bandwidth
%b_c = pairwise communication bandwidth
%n = |VMs| = |Chunks|


%Header Extensions Seperation
%Carlo
\newcommand{\Capacity}{\ensuremath{\textsc{cap}}}
\newcommand{\VM}{\textsc{VM}}
\newcommand{\Chunk}{\ensuremath{c}}
\newcommand{\Problem}{\textsc{DummyName Problem}}
\newcommand{\carlo}[1]{\textcolor{red}{#1}}
\newcommand{\MaFactor}{\ensuremath{\textsc{MA}}}
\newcommand{\Path}{\ensuremath{p}}
\newcommand{\RedundancyFactor}{\ensuremath{r}}

\newcommand{\VmChunkAssignment}{\ensuremath{ASS_v}}
\newcommand{\NodeMapping}{\ensuremath{MAP_v}}
\newcommand{\ChunkLocation}{\ensuremath{Location}}

\newcommand{\ChunkType}{\ensuremath{textsc{ct}}}
\newcommand{\VirtualNodes}{\ensuremath{V_V}}
\newcommand{\VirtualEdges}{\ensuremath{E_V}}
\newcommand{\VirtualNode}{\ensuremath{v}}
\newcommand{\VirtualEdge}{\ensuremath{e}}
\newcommand{\VCSwitch}{\ensuremath{\textsc{center}}}
\newcommand{\SubstrateNodes}{\ensuremath{V_S}}
\newcommand{\SubstrateEdges}{\ensuremath{E_S}}
\newcommand{\SubstrateNode}{\ensuremath{v}}
\newcommand{\SubstrateEdge}{\ensuremath{e}}
\newcommand{\Leaf}{\ensuremath{l}}
\newcommand{\Leaves}{\ensuremath{L}}
\newcommand{\Chunks}{\ensuremath{\textsc{chunks}}}


\newcommand{\VC}{\textsc{VC}}
\newcommand{\CC}{\textsc{CC}}

\newcommand{\VE}{\textsc{VE}}
\newcommand{\FP}{\textsc{FP}}
\newcommand{\RS}{\textsc{RS}}
\newcommand{\BW}{\textsc{BW}}
\newcommand{\MA}{\textsc{MA}}
\newcommand{\Cost}{\textsc{Cost}}

\newcommand{\MatchCost}{\textsc{MCost}}
\newcommand{\chunkOf}{\textsc{chunkOf}}


%Maciek

\newcommand{\Bandwidth}{\ensuremath{bw}}
\newcommand{\Tree}{\ensuremath{T}}
\newcommand{\CostCom}{\ensuremath{b_1}}
\newcommand{\CostTrans}{\ensuremath{b_2}}
\newcommand{\Vms}{\ensuremath{VM}}


\newcommand{\Formula}{\ensuremath{\Psi}}
\newcommand{\Clauses}{\ensuremath{Cl(\Formula)}}
\newcommand{\NClauses}{\ensuremath{c}}
\newcommand{\Vars}{\ensuremath{Var(\Formula)}}
\newcommand{\NVars}{\ensuremath{|\Vars|}}
\newcommand{\ChunkTypes}{\ensuremath{ch}}
\newcommand{\Thr}{\ensuremath{Th}}
\newcommand{\VCB}{\ensuremath{VCB}}
\newcommand{\VCNB}{\ensuremath{VCNB}}
\newcommand{\varx}{\ensuremath{x}}
\newcommand{\positive}{\ensuremath{positive}}
\newcommand{\negative}{\ensuremath{negative}}
\newcommand{\SAT}{\ensuremath{SAT}}
\newcommand{\TSAT}{\ensuremath{3SAT}}
\newcommand{\Val}{\ensuremath{Val}}
\newcommand{\Sol}{\ensuremath{SOL}}



\definecolor{blueLink}{rgb}{0,0.2,0.8}
\hypersetup{colorlinks,linkcolor=blueLink,urlcolor=blueLink,citecolor=blueLink}
\newcommand{\lref}[2][]{\hyperref[#2]{#1~\ref*{#2}}}



\input{macros}

\title{A Note on Virtual Cluster Embedding with Data Locality}

\title{Embedding Algorithms for Virtual Clusters with Data Locality and Replica Selection}

\title{Embedding Virtual Clusters with Data Locality and Replica Selection\\{\Large Real Algorithms for Virtual Environments}}

\title{Data Locality and Replica Aware Virtual Cluster Embeddings in Fat-Trees\\{\Large Real Algorithms for Virtual Environments}}


\author{Carlo Fuerst$^1$, Maciek Pacut$^2$, Stefan Schmid$^3$\\
$^1$ TU Berlin, Germany; $^2$ University of Wroclaw, Poland; $^3$ TU Berlin \& T-Labs, Germany}

\begin{document}

\maketitle


\begin{abstract}
\textbf{Abstract.} Virtualized datacenters offer great flexibilities in terms of resource allocation. In particular, by
decoupling applications from the constraints of the underlying physical infrastructure, virtualization
supports an optimized mapping of virtual machines as well as their interconnecting network (the so-called \emph{virtual cluster}) to their
physical counterparts: essentially a graph embedding problem. 

However, existing algorithms 
in the literature often ignore a crucial dimension of the embedding problem, namely \emph{data locality}: 
the input to a cloud application such as MapReduce is typically stored in a distributed,
and sometimes redundant, file system or database. Since moving this data is costly, an embedding algorithm should be data locality aware,
and allocate computation close to the data; in case of redundant storage, the algorithm should also optimize the \emph{replica selection}.

This paper initiates the algorithmic study of data locality aware virtual cluster embeddings in fat-tree datacenter topologies. 
In particular, we 
show that
despite the many degrees of freedom of the embedding, many problems can be
solved efficiently, and we highlight interesting connections
to classic optimization problems, such as matchings
flow problems. However, we also show the limitations of such optimizations, 
by presenting several new NP-hardness results; interestingly, 
our hardness proofs are for uncapacitated settings. 
\end{abstract}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Introduction}

Server virtualization has revamped the server business over the last years,
and has radically changed the way we think about resource allocation:
today, almost arbitrary computational resources can be allocated on demand.
Moreover, the virtualization trend now started to spill over to the network: 
batch-processing applications such as MapReduce often generate significant
network traffic (namely during the so-called shuffle phase)~\cite{amazonbw}, 
and in order to avoid interference in the underlying physical network and in order to provide a predictable
application performance, it is important to provide performance isolation and bandwidth guarantees 
for the virtual network connecting the virtual machines.~\cite{talk-about}

Server and network virtualization introduces interesting resource allocation flexibilities,
in the sense that virtual machines and their interconnecting network,
can in principle be embedded \emph{anywhere} in the datacenter. The resulting flexibilities
can be exploited for various optimizations; 
however, the joint optimization of node and link mapping is often non-trivial.~\cite{pb-embed} 
Over the last years, especially the problem of embedding
\emph{Virtual Clusters} has been studied intensively. Virtual clusters are the most popular abstraction for batch-processing applications:
a virtual cluster connects a set of virtual machines by providing pair-wise bandwidth guarantees.
In order to provide resource-efficiency, existing algorithms aim to map virtual machines as close as possible
in the datacenter, which minimizes communication costs.~\cite{oktopus,proteus}

However, existing embedding algorithms often ignore an important aspect: the fact that the input data
to batch-processing applications,
the so-called \emph{chunks}, are stored in a distributed file system or database. In order to minimize
costly data transmissions, an embedding algorithm should be \emph{data locality aware},
and map compute units close to the chunk locations. Moreover, in case of redundant storage (batch processing
applications often provide a 3-fold redundancy), the algorithm should exploit flexibilities in
the \emph{(chunk) replica selection}.

\subsection{Our Contributions}

This paper initiates the study of data-locality and replica aware embedding problems in virtualized datacenters.
In particular, we decompose the optimization problem into different fundamental models, in terms of flexible
node placement, capacity constraints, or replication,
and draw an almost complete picture of the problem space. Concretely, we show that several problems
can be solved optimally in polynomial time, despite the large degrees of freedom, and also highlight
computational hardness limitations. Interestingly, while it is well-known that (unsplittable) multi-commodity flow
problems are NP-hard in capacitated networks, our results highlight the hardness of several uncapacitated 
optimization problems.


\subsection{Organization}

The remainder of this paper is organized as follows. 
Section~\ref{sec:model} introduces our formal model in detail.
Algorithms are presented in Section~\ref{sec:poly} and
hardness results are presented in Section~\ref{sec:np}.
After discussing related work in Section~\ref{sec:relwork},
we conclude our work in Section~\ref{sec:conclusion}.


\section{Model}\label{sec:model}

We will first present our model formally, and subsequently discuss how it relates
to batch-processing applications. 

\textbf{Fundamental Parts.} Our model consists of three fundamental parts: (1) the substrate network,
(2) the input data, and 
(3) the virtual network. 
The substrate network (also known as the \emph{host graph}) describes the physical resources: the servers 
and the inter-connecting datacenter topology. 
We assume that servers have a certain capacity, in terms of the number of virtual machines or compute units they
can host. The servers are interconnected by a fat-tree network. Concretely, we assume a tree network
$G=(V,E)$ where $V=S \cup R$ describes the set $S$ of servers (located at the leaves) which are inter-connected
via routers (or switches) $R$ by links $E$.
The problem input is stored in the form of \emph{chunks} which are distributed across the servers;
chunks may be redundant.
The virtual network consists of virtual machines (henceforth often simply called \emph{nodes}) which need to be mapped to substrate servers.
Since these virtual machines process the input data, they need to be assigned and connected to the
chunks; each virtual machine should be assigned the same number of chunks (up to rounding issues if
the number of chunks is not a perfect multiple of the number of virtual machines). Moreover, virtual machines need to be connected among each other.
In order to provide performance guarantees, both the connection to the chunks
as well as the interconnection between the virtual machines must provide a certain
minimal bandwidth guarantee; we will refer to the first type of network as the \emph{input 
network}, and to the second type of network as the \emph{inter-connect}. The inter-connect will
is modelled as a complete network (a virtual cluster).

FIXME: introduce formal concepts

\textbf{Optimization Objective.} Our goal is to develop algorithms which minimize
the resource footprint: the overall bandwidth allocation in the datacenter. That is,
we aim to embed virtual machines close to the input data as well as close to
each other.

FIXME: add an overview picture

\textbf{Problem Decomposition.}
In order to provide a complete picture of the tractability and intractability of different
problem variants, we decompose our problem into its fundamental aspects.
First, we distinguish between an uncapacitated and a capacitated scenario where the links of the substrate network come with bandwidth
constraints, and will refer to the bandwidth-constrained version by $\BW$.
Second, we distinguish whether the virtual machines only need to be connected to the chunks, or also
among each other; we will refer to the model where an inter-connect is required
by $\CC$.
Third, we will distinguish whether data is stored redundantly or not; we will refer to the variant
with replica selection, i.e., where the algorithm can choose from multiple replicas, by $\RS$.
We also distinguish between a scenario where multiple chunks need to be assigned to a node
(called $\MA$), and one where there are less chunks than virtual machines. 
Finally, we note that in scenarios with replicated input, the problem of assigning replicas
to nodes is already interesting if the location of nodes is \emph{given} and cannot be optimized,
we distinguish between a scenario where the node placement is flexible (called $\FP$) and one where
it is not.

\textbf{Remark on Practical Relevance.}


fatrees are , the standard datacenter topology today. CITE

reduction ratio

nodes could be compute units only

virtual clusters

The servers of the datacenters provide a distributed file system or database

%\subsection{Our Contributions}
%
%This paper takes a closer look at the fundamental resource allocation problems
%in virtual network environments, studying and distinguishing between flexibilities in virtual machine placements ($\FP$) and
%replica selection ($\RS$), taking into account communication costs ($\CC$) and bandwidth constraints ($\BW$).
%
%We make the following contributions.
%\begin{enumerate}
%\item We show that the virtual cluster embedding dyn prog and flow
%\item We show that the other is matching
%\item NP-hardness
%\end{enumerate}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\section{Algorithms}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\subsection{Model variants}
\input{models}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Polynomial-Time Algorithms}\label{sec:poly}

This section gives an overview over model variants which can be solved, and
explains the corresponding algorithms. Figure~\ref{fig:summary} contains an
overview which problems can be solved, and with which algorithms.
\input{matching}
\input{flow}

%\subsection{Dynamic programming solution}
\input{dynamic_embedding}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{NP-Hardness Results}\label{sec:np}

\input{np-completeness}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Related Work}\label{sec:relwork}

It is well-known~\cite{talk-about} that the network
can have a significant impact on cloud application
performance, and several solutions have been proposed
over the last years to provide more predictable
network guarantees, such as avoiding multi-tenancy
entirely (see e.g., Amazon's Compute Cluster), by providing relative max-min
per-flow or per-tenant fairness
guarantees~\cite{seawall,netshare,faircloud,elasticswitch}, or by
explicit bandwidth
reservations~\cite{gatekeeper,secondnet,oktopus, proteus, drl}.

Our work focuses on systems with strict performance guarantees,
and there exists a large body of literature
on the general virtual network embedding problem, see~\cite{alloc-survey} for a good survey.
We consider the virtual cluster abstraction proposed
in the Oktopus~\cite{oktopus} paper, and later also studied in
the Proteus~\cite{proteus} paper. However, both papers only present
heuristic algorithms for the virtual cluster embedding problem.
While on average and in our simulations Oktopus~\cite{oktopus} and
Proteus~\cite{proteus} find good embeddings with small footprints,
it is easy to see that the resulting resource footprint
can be arbitrarily bad compared to the optimal solution.
Oktopus can miss solutions where the virtual cluster
is embeddable on a single server, and Proteus can miss efficient embeddings
spanning more than one pod.

FIXME: data locality, matching, etc.

It is well-known~\cite{talk-about} that the network
can have a significant impact on cloud application
performance, and several solutions have been proposed
over the last years to provide more predictable
network guarantees, such as avoiding multi-tenancy
entirely (see e.g., Amazon's Compute Cluster), by providing relative max-min
per-flow or per-tenant fairness
guarantees~\cite{seawall,netshare,faircloud,elasticswitch}, or by
explicit bandwidth
reservations~\cite{gatekeeper,secondnet,oktopus, proteus, drl}.

Our work focuses on systems with strict performance guarantees,
and there exists a large body of literature
on the general virtual network embedding problem, see~\cite{alloc-survey} for a good survey.
We consider the virtual cluster abstraction proposed
in the Oktopus~\cite{oktopus} paper, and later also studied in
the Proteus~\cite{proteus} paper. However, both papers only present
heuristic algorithms for the virtual cluster embedding problem.
While on average and in our simulations Oktopus~\cite{oktopus} and
Proteus~\cite{proteus} find good embeddings with small footprints,
it is easy to see that the resulting resource footprint
can be arbitrarily bad compared to the optimal solution.
Oktopus can miss solutions where the virtual cluster
is embeddable on a single server, and Proteus can miss efficient embeddings
spanning more than one pod.

Finally, we refer the reader to Duffield et al.~\cite{hose-vpn} for an early work
 on \emph{hose}-type specifications in the context of VPN embeddings, and to Gupta et al.~who
 provided and inspired important results also pertaining to hose-based
 virtual cluster embeddings \cite{gupta2001provisioning,Goyal2008}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Conclusion}\label{sec:conclusion}

FIXME

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Appendix}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\bibliographystyle{alpha}
\bibliography{references}

\end{document}
